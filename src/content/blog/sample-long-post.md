---
title: "大規模フロントエンド基盤のリファクタリングとパフォーマンスチューニングの全記録"
description: "ReactとAstroを用いたモダンフロントエンド開発における、大規模なパフォーマンス改善とアーキテクチャの刷新についての長編記録です。"
pubDate: "2026-02-24"
tags: ["React", "Astro", "Performance", "Engineering", "Architecture"]
---

## はじめに：なぜリファクタリングが必要だったのか

これまで運用を続けてきたポートフォリオサイトですが、コンテンツの増加やUIアニメーションの拡充に伴い、いくつかの課題が浮上してきました。初期の段階では十分だった構成も、コードベースが肥大化するにつれてメインテナンス性が低下し、特にブラウザ上での描画パフォーマンスに影響が出始めていました。

本記事では、この課題にどのようにアプローチし、Astro と React を用いた最適化をどのように実現したのか、その全記録をお届けします。

## 課題の明確化と初期分析

パフォーマンスのボトルネックを特定するため、まずは Chrome Lighthouse を用いて現行のサイトを分析しました。その結果、以下の要素がスコア低下の主な要因であることが判明しました。

1. **過度な JavaScript バンドルサイズ**
   初期ロード時に必要のないコンポーネントの JS まで一括して読み込まれていました。
2. **メインスレッドのブロック**
   複雑な Framer Motion アニメーションが同時に実行されることで、ブラウザのメインスレッドが占有され、クリックなどのユーザー操作が遅延していました。
3. **無駄な再レンダリング**
   React コンポーネントの State 管理が適切に分割されておらず、一部の更新がページ全体の再描画を引き起こしていました。

### ボトルネックの特定手法

Lighthouse だけでなく、Chrome DevTools の Performance タブを活用し、どの関数がどれだけのミリ秒を消費しているか、コールツリーを詳細にトラッキングしました。

## 改善策1: アイランドアーキテクチャの徹底活用

Astro の最大の特徴である「アイランドアーキテクチャ（Island Architecture）」を、これまで以上に厳格に適用することにしました。

### `client:load` と `client:visible` の使い分け

インタラクティブである必要のない静的なUI部分はすべてプレーンな HTML / Astro コンポーネントに置き換えました。React コンポーネントを残した部分についても、初期表示で絶対にインタラクションが必要なものは `client:load` とし、スクロールして初めて画面に入る要素（グラフやフッター部分のウィジェットなど）には `client:visible` を指定しました。

これにより、初回ロード時の JavaScript 解析と実行コストを劇的に下げることに成功しました。

## 改善策2: アニメーションの GPU アクセラレーション化

アニメーションのパフォーマンス改善は、ユーザーの「サクサク感」に直結します。

### `will-change` プロパティの戦略的配置

Framer Motion でアニメーションさせている要素に対し、意図的にCSSの `will-change: transform, opacity` を付与しました。これにより、ブラウザはそれらの要素が変化することを事前に予測し、独立したレイヤーとしてGPUへレンダリングをオフロードします。

```css
.accelerated-layer {
  will-change: transform, opacity;
  transform: translateZ(0); /* ハードウェアアクセラレーションの強制トリガー */
}
```

ただし、`will-change` の乱用はかえってメモリを消費するため、アニメーションが終了したタイミングでクラスを外すフックも独自に実装しました。

## 改善策3: 状態管理の局所化

これまでは、グローバルな状態管理（Zustandなど）に依存している箇所が多くありました。これを根本から見直しました。

### Context API からの脱却と Jotai の導入

Context API は便利ですが、Provider 配下のコンポーネントが無条件に再レンダリングされるという欠陥があります。今回は Atomic な状態管理ライブラリである Jotai を導入し、状態（State）を極小単位に分割しました。結果として、Navボタンのホバー状態が変わっても、隣接する他のコンポーネントが再描画されることはなくなりました。

## D3.js と React を用いたグラフ描画の最適化

本サイトの目玉でもある SystemGraph コンポーネントは、D3.js の Force Directed Graph を用いて描画されています。ノード数が増えると描画負荷が高くなります。

### SVG vs Canvas vs DOM

初期は全てを SVG で描画していましたが、ノード数が増加すると DOM の数が急激に増え、スクロール時にカクつき（Jank）が発生しました。

最終的に、**線（リンク）は SVG** で描き、**ノードは React (DOM)** でオーバーレイさせるというハイブリッドなアプローチを採用し、さらにアニメーション計算 (`d3.forceSimulation`) を Web Worker へオフロードする設計設計の導入も検討しましたが、今回は `requestAnimationFrame` にフックして React の状態を更新するにとどめました。

十分なパフォーマンスが出るように Force Simulation の tick ごとの state 更新頻度も最適化しています。

## デザインシステムとの統合

最適化を行いつつも、UI の美しさを損なわないことが重要です。

Tailwind CSS を用いて構築した社内（個人チーム）向けデザインシステムと、これらの最適化手法をうまく統合するために、コンポーネント設計のレイヤーを厳重に分けました。UI を司る Presentational Component と、ロジック・状態・アニメーションを担う Container Component に分離することで、今後の拡張性が飛躍的に向上しました。

### スクロール連動型グラフィックについて

本ブログ詳細ページの右側に見えている「Context Graph」ですが、これもページスクロールに追従（Sticky）する仕組みが入っています。ブラウザのスクロールイベントは非常に発火頻度が高いため、これを直接 React の State で追うのは御法度です。

今回は CSS の `position: sticky` を採用しつつ、JavaScript 側での IntersectionObserver を併用して、グラフィックスが画面のどこにあるかによって計算を停止・再開するロジックを組み込み、エコな設計を目指しました。

## 今後の展望

今回のリファクタリングにより、ポートフォリオサイトは新たなフェーズに突入しました。

1. **ブログコンテンツの拡充**：今回のこの長編記事もテストケースの一環ですが、今後さらに技術的な知見を「Logs」として蓄積していきます。
2. **WebGL の導入**：TOPページの表現力をさらに高めるため、Three.js や React Three Fiber を用いた 3D パーティクル表現の統合を実験的に行う予定です。
3. **継続的なパフォーマンス監視**：一度の改善で終わらせず、Vercel Analytics などを用いてリアルユーザーモニタリング（RUM）を確立し、劣化を検知できる仕組みを作ります。

## おわりに

大規模なフロントエンドシステムの改善は、まるで動いている車のタイヤを交換するような難しさがあります。しかし、Astro と React という現代の強力なツール群を適切に使いこなすことで、驚くほど美しいUIとパフォーマンスを両立させることが可能です。

この記録が、同様の課題に直面している他の開発者にとって少しでも参考になれば幸いです。

これからも System Record を更新し続けます。最後まで読んでいただきありがとうございました。
